# -*- coding: utf-8 -*-
"""DL4回目_20181227_01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HETqvM5AGvQblG2EtY32s14JyNIn_tJw
"""

# %matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

import pandas as pd
import seaborn as sns

from sklearn import datasets

iris = sns.load_dataset('iris')

data = iris[:100]
columns = ['petal_width', 'petal_length']
x = data[columns]
y = data['species']

y = (y == 'setosa').astype(int)

def plot_iris(x, y, colors, ax=None):
  if ax is None:
    fig = plt.figure()
    ax = fig.add_subplot(1, 1, 1)
    
  plt.figure()
  x1 = x.columns[0]
  x2 = x.columns[1]
  
  for (species, group), c in zip(x.groupby(y), colors):
    group.plot(kind='scatter', x=x1, y=x2, color=c, ax=ax)
  
  return ax
    
plot_iris(x, y, colors=['red', 'blue'])
plt.show()

def sigmoid(x):
  return 1. / (1. + np.exp(-x))

def calc_y(x, w, b):
  return sigmoid(np.dot(x, w) + b)

def calc_grad(x, y, w, b):
  error = y - calc_y(x, w, b)
  w_grad = -np.mean(x.T * error, axis=1)
  b_grad = -np.mean(error)
  return w_grad, b_grad

nb_epochs = 30

def GradientDescent(x, y, w, b, eta=1.2):
  for i in range(1, nb_epochs):
    w_grad, b_grad = calc_grad(x, y, w, b)
    w = w - eta * w_grad
    b = b - eta * b_grad
    e = np.mean(np.abs(y - calc_y(x, w, b)))
    yield i, w, b, e

# %matplotlib inline

def plot_result(x, y, solver, title):
  fig = plt.figure()
  
  ax = fig.add_subplot(1, 1, 1)
  plt.xlim([0.0, 2.0])
  plt.ylim([-1.0, 6.0])
  
  art_objs = []
  
  bx = np.arange(x.iloc[:, 0].min(), x.iloc[:, 0].max(), 0.1)
  
  w, b = np.zeros(2), 0
  gen = solver(x, y, w, b)
  
  for i, w, b, e in gen:
    by = -b / w[1] - w[0] / w[1] * bx
    
    l = ax.plot(bx, by, color='gray', linestyle='dashed', alpha=(i/nb_epochs)/2.+0.5)
    
    art_objs.append(l)
  
  ax = plot_iris(x, y, colors=['red', 'blue'], ax=ax)
  ax.set_title(title)
  plt.show()
  
  print(w)

plot_result(x, y, GradientDescent, title='GD')

def SGD(x, y, w, b, eta=0.2): # = online
  for i in range(1, nb_epochs):
    indexer = np.arange(x.shape[0]) # x.shape[0]はデータ件数が入っている
    np.random.shuffle(indexer)
    for index in indexer:
      _x = x.iloc[[index], ] # xをランダムに1件だけとってくる
      _y = y.iloc[[index], ] # yをランダムに1件だけとってくる
      w_grad, b_grad = calc_grad(_x, _y, w, b)
      w = w - eta * w_grad
      b = b - eta * b_grad
      e = np.mean(np.abs(y - calc_y(_x, w, b)))
      yield i, w, b, e

plot_result(x, y, SGD, title='SGD')